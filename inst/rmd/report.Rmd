---
title: "`r paste('PaRe Report:', basename(params$pkgPath))`"
author: "`r paste('PaRe', packageVersion('PaRe'))`"
date: "`r Sys.Date()`"
output: html_document
params:
  pkgPath: pkgPath
  showCode: showCode
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## External Resources
### Style Guide
The styling is based on the following style guide:

- [Tidyverse styleguide](https://style.tidyverse.org/syntax.html)
- [HADES styleguide](https://ohdsi.github.io/Hades/codeStyle.html)

### Cyclomatic Complexity
>[Cyclomatic Complexity](https://en.wikipedia.org/wiki/Cyclomatic_complexity) is a software metric used to indicate the complexity of a program. It is a quantitative measure of the number of linearly independent paths through a program's source code. It was developed by Thomas J. McCabe, Sr. in 1976.

And is calculated as follows: $M = E - N + 2P$

The complexity score is interpreted as follows:

> 
> - 1-10 Simple procedure, little risk
> - 11-20 More complex, moderate risk
> - 21-50 Complex, high risk
> - \>50 Untestable code, very high risk
> 

[link, 2023-02-10](https://en.wikipedia.org/wiki/Cyclomatic_complexity#Interpretation)

## Dependency review
### Check dependencies against whitelist
```{r chedkDependencies, echo=params$showCode, message=FALSE, warning=FALSE}
DT::datatable(PaRe::checkDependencies(pkgPath = params$pkgPath))
```

### Dependency characteristics
**countVertices**: The amount of recursive dependencies `r params$pkgPath` depends on.
**countEdges**: The total amount of imports of all dependencies.
**meanDegree**: The average amount of imports per dependency.
**meanDistance**: The average dependency layers between `r params$pkgPath` and all other recursive dependencies.
```{r}
graphData <- getGraphData(path = params$pkgPath)

DT::datatable(data.frame(
  countVertices = length(igraph::V(graphData)),
  countEdges = length(igraph::E(graphData)),
  meanDegree = round(mean(igraph::degree(graphData)), 2),
  meanDistance = round(mean(igraph::distances(graphData)), 2)
  ))
```

```{r}
p <- igraph::all_simple_paths(
  graph = graphData,
  from = igraph::farthest.nodes(graphData)$vertices[1],
  to = igraph::farthest.nodes(graphData)$vertices[2])


ggraph::ggraph(
  graph = igraph::induced_subgraph(graphData, p[[1]]),
  layout = "tree") +
  ggraph::geom_edge_link() +
  ggraph::geom_node_label(
    mapping = ggplot2::aes(
      label = name)) +
  ggplot2::theme_void()
```


### Function use per dependency
```{r summariseFunctionUse, echo=params$showCode, message=FALSE, warning=FALSE}
funsUsed <- PaRe::summariseFunctionUse(
  list.files(normalizePath(paste0(params$pkgPath, "/R")), full.names = TRUE))

DT::datatable(funsUsed)
```

```{r getDefinedFunctionsPkg, echo=params$showCode, message=FALSE, warning=FALSE}
defFuns <- PaRe::getDefinedFunctionsPkg(params$pkgPath)
```

```{r plotFunctionUse, dpi=100, fig.height=25, out.width="100%", echo=params$showCode, message=FALSE, warning=FALSE}
function_sub <- funsUsed %>% 
  dplyr::filter(!pkg %in% c("base"))

fun_counts <- function_sub %>%
  dplyr::group_by(fun, pkg, name = "n") %>%
  dplyr::tally()

# Filter functions that are defined in the package
nonPkgFuns <- fun_counts[!fun_counts$fun %in% defFuns$fun, ]

ggplot2::ggplot(
  data = nonPkgFuns,
  mapping = ggplot2::aes(x = .data$fun, y = .data$n, fill = .data$pkg)) +
  ggplot2::geom_col() +
  ggplot2::facet_wrap(
    dplyr::vars(.data$pkg),
    scales = "free_x",
    ncol = 2) +
  ggplot2::theme_bw() +
  ggplot2::theme(
    legend.position = "none",
    axis.text.x = (ggplot2::element_text(angle = 45, hjust = 1, vjust = 1)))
```

## Package Review
### Package Diagram
```{r packageDiagram, out.width="100%", echo=params$showCode}
PaRe::pkgDiagram(pkgPath = params$pkgPath)
```


### Defined functions in the package
```{r definedFunctions, echo=params$showCode}
DT::datatable(defFuns)
```

### Lintr
```{r lintScores, echo=params$showCode, message=FALSE, warning=FALSE}
DT::datatable(PaRe::lintScore(PaRe::lintPackage, params$pkgPath))
```

```{r lintMessages, echo=params$showCode, message=FALSE, warning=FALSE}
lintMsgs <- data.frame(PaRe::lintPackage(params$pkgPath))

DT::datatable(
  lintMsgs %>%
  dplyr::group_by(message) %>%
  dplyr::tally(sort = TRUE)
)
```
